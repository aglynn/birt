<?php require_once("includes/Java.inc");

/**
 * @file
 *
 * (Note that custom node types are most often created with CCK in recent
 * versions of Drupal.)
 *
 * Our BIRT Open Source node type will allow users to specify a "reportname"
 * for their nodes. To store this extra information, we need an auxiliary database table.
 *
 * Database definition:
 * @code
 *   CREATE TABLE birt (
 *     vid int(10) unsigned NOT NULL default '0',
 *     nid int(10) unsigned NOT NULL default '0',
 *     reportname varchar(255) NOT NULL default '',
 *     PRIMARY KEY (vid, nid),
 *     KEY `birt_nid` (nid)
 *   )
 * @endcode
 */

/**
* Display help and module information
* @param path which path of the site we're displaying help
* @param arg array that holds the current path as would be returned from arg() function
* @return help text for the path
*/
function birt_help($path, $arg) {
  $output = '';  //declare your output variable
  switch ($path) {
    case "admin/help#birt":
      $output = '<p>' . t("Executes and displays BIRT content") . '</p>';
      break;
  }
  return $output;
} // function birt_help

/**
 * Implementation of hook_node_info(). This function replaces hook_node_name()
 * and hook_node_types() from 4.6. Drupal 5 expands this hook significantly.
 *
 * This is a required node hook. This function describes the nodes provided by
 * this module.
 *
 * The required attributes are:
 * - "name" provides a human readable name for the node,
 * - "module" tells Drupal how the module's functions map to hooks (i.e. if the
 *   module is node_example_foo then node_example_foo_insert will be called
 *   when inserting the node).
 * - "description" provides a brief description of the node type, which is
 *   shown when a user accesses the "Create content" page for that node type.
 *
 * The other optional, attributes:
 * - "has_title" boolean that indicates whether or not this node type has a
 *   title field.
 * - "title_label": the label for the title field of this content type.
 * - "has_body": boolean that indicates whether or not this node type has a
 *   body field.
 * - "body_label": the label for the body field of this content type.
 * - "min_word_count": the minimum number of words for the body field to be
 *   considered valid for this content type.
 */
function birt_node_info() {
  return array(
    'birt' => array(
      'name' => t('BIRT Content'),
      'base' => 'birt',
      'description' => t("This module is used to execute and display BIRT content."),
    )
  );
}

/**
 * Implementation of hook_node_access().
 *
 * Node modules may implement node_access() to determine the operations
 * users may perform on nodes. This example uses a very common access pattern.
 */
function birt_node_access($node, $op, $account) {
  if ($op == 'create') {
    return user_access('create birt content', $account);
  }

  if ($op == 'update') {
    if (user_access('edit any birt content', $account) || (user_access('edit own birt content', $account) && ($account->uid == $node->uid))) {
      return NODE_ACCESS_ALLOW;
    }
  }

  if ($op == 'delete') {
    if (user_access('delete any birt content', $account) || (user_access('delete own birt content', $account) && ($account->uid == $node->uid))) {
      return NODE_ACCESS_ALLOW;
    }
  }
}

/**
 * Implementation of hook_permission().
 *
 * Since we are limiting the ability to create new nodes to certain users,
 * we need to define what those permissions are here. We also define a permission
 * to allow users to edit the nodes they created.
 */
function birt_permission() {
  return array(
    'create birt content',
    'delete own birt content',
    'delete any birt content',
    'edit own birt content',
    'edit any birt content',
  );
}
function birt_admin() {
  $form = array();

  $form['birt_reportfolderlocation'] = array(
    '#type' => 'textfield',
    '#title' => t('Folder name that contains the BIRT reports (rptdesign files), starting from the current working directory of the site, which is at ' . getcwd()),
    '#default_value' => variable_get('birt_reportfolderlocation', 'reports'),
    '#size' => 50,
    '#maxlength' => 50,
    '#description' => t("The location of the folder that contains the BIRT reports."),
    '#required' => TRUE
  );

  return system_settings_form($form);
} // function birt_admin

function birt_menu() {

  $items = array();

  $items['admin/settings/birt'] = array(
    'title' => 'BIRT OS module settings',
    'description' => 'This page allows the setting of your report repository folder',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('birt_admin'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
} // function birt_menu

function birt_admin_validate($form, &$form_state) {
}

/**
 * Implementation of hook_form().
 *
 * Now it's time to describe the form for collecting the information
 * specific to this node type. This hook requires us to return an array with
 * a sub array containing information for each element in the form.
 */
function birt_form(&$node) {
  // The site admin can decide if this node type has a title and body, and how
  // the fields should be labeled. We need to load these settings so we can
  // build the node form correctly.
  node_type_clear();
  $type = node_type_get_name($node);

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => t('Title'),
    '#required' => TRUE,
    '#default_value' => $node->title,
    '#weight' => -5
    );

  // Now we define the form elements specific to our node type.
  $form['reportname'] = array(
  '#type' => 'textfield',
  '#title' => t('Report Name'),
  '#required' => TRUE,
  '#default_value' => isset($node->reportname) ? $node->reportname : '',
  '#weight' => -4
  );

  return $form;
}

/**
 * Implementation of hook_validate().
 *
 * Our "quantity" field requires a number to be entered. This hook lets
 * us ensure that the user entered an appropriate value before we try
 * inserting anything into the database.
 *
 * Errors should be signaled with form_set_error().
 */
function birt_validate($node) {
}

/**
 * Implementation of hook_insert().
 *
 * As a new node is being inserted into the database, we need to do our own
 * database inserts.
 */
function birt_insert($node) {
  db_query("INSERT INTO {birt} (vid, nid, reportname) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $node->reportname);
}

/**
 * Implementation of hook_update().
 *
 * As an existing node is being updated in the database, we need to do our own
 * database updates.
 */
function birt_update($node) {
  // if this is a new node or we're adding a new revision,
  if ($node->revision) {
    birt_insert($node);
  }
  else {
    db_query("UPDATE {birt} SET reportname = '%s' WHERE vid = %d", $node->reportname, $node->vid);
  }
}

/**
 * Implementation of hook_node_revision_delete().
 *
 * When a node revision is deleted, we need to remove the corresponding record
 * from our table. The only way to handle revision deletion is by implementing
 * hook_nodeapi().
 */

function birt_node_revision_delete(&$node) {
  // Notice that we're matching a single revision based on the node's vid.
  db_query('DELETE FROM {birt} WHERE vid = %d', $node->vid);
}

/**
 * Implementation of hook_delete().
 *
 * When a node is deleted, we need to remove all related records from our table.
 */
function birt_delete($node) {
  // Notice that we're matching all revision, by using the node's nid.
  db_query('DELETE FROM {birt} WHERE nid = %d', $node->nid);
}

/**
 * Implementation of hook_load().
 *
 * Now that we've defined how to manage the node data in the database, we
 * need to tell Drupal how to get the node back out. This hook is called
 * every time a node is loaded, and allows us to do some loading of our own.
 */
function birt_load($node) {
  $additions = db_fetch_object(db_query('SELECT reportname FROM {birt} WHERE vid = %d', $node->vid));
  return $additions;
}

/**
 * Implementation of hook_view().
 *
 * This is a typical implementation that simply runs the node text through
 * the output filters.
 */
function birt_view($node, $teaser = FALSE, $page = FALSE) {
  $node = node_prepare($node, $teaser);
  $node->content['myfield'] = array(
    '#value' => theme('birt_display_content', $node),
    '#weight' => 1,
  );

  return $node;
}

/**
 * Implementation of hook_theme().
 *
 * This lets us tell Drupal about our theme functions and their arguments.
 */
function birt_theme() {
  return array(
    'birt_display_content' => array(
      'arguments' => array('node'),
    ),
  );
}

/**
 * A custom theme function.
 *
 * By using this function to format our node-specific information, themes
 * can override this presentation if they wish. We also wrap the default
 * presentation in a CSS class that is prefixed by the module name. This
 * way, style sheets can modify the output without requiring theme code.
 */
function theme_birt_display_content($node) {
  
  // PHP_SELF points to /drupal-6.17/index.php

  $directory = dirname($_SERVER["PHP_SELF"]);    

  $pth = "http://" . $_SERVER["HTTP_HOST"] . $directory;  
  $path = parse_url($pth);
  $imageURLPrefix = $path['scheme'] . '://' . $path['host'] . $path['path'] . "/sessionChartImages/";

  session_start(); 
  $here = getcwd();

  $ctx = java_context()->getServletContext();
  $birtReportEngine = java("org.eclipse.birt.php.birtengine.BirtEngine")->getBirtEngine($ctx);
  java_context()->onShutdown(java("org.eclipse.birt.php.birtengine.BirtEngine")->getShutdownHook());

  try{
    // Get the report folder name that contains all the .rptdesign files
    $reportFolder = variable_get("birt_reportfolderlocation", "reports");

    $report = $birtReportEngine->openReportDesign("${here}/$reportFolder/" . $node->reportname);
    $task = $birtReportEngine->createRunAndRenderTask($report);
    //$task->setParameterValue("Top Count", new java("java.lang.Integer", 6));

    $taskOptions = new java("org.eclipse.birt.report.engine.api.HTMLRenderOption");
    $outputStream = new java("java.io.ByteArrayOutputStream");
    $taskOptions->setOutputStream($outputStream);
    $taskOptions->setOutputFormat("html");
    $ih = new java( "org.eclipse.birt.report.engine.api.HTMLServerImageHandler");
    $taskOptions->setImageHandler($ih);

    $taskOptions->setBaseImageURL($imageURLPrefix . session_id());
    $taskOptions->setImageDirectory($here . "/sessionChartImages/" . session_id());

    $task->setRenderOption( $taskOptions );
    $task->run();
    $task->close();

  } catch (JavaException $e) {
    echo $e; //"Error Calling BIRT";
  }
  // Return the generated output to the client
  $page_content .= java_values($outputStream);

  // check to see if there was any content before
  // returning the page
  if ($page_content == '') {
    // no content from a week ago, let the user know
    $page_content = "No content returned from " . $node->reportname;
  }
  return $page_content;

}
